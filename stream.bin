SEMINAR 1
# include < stdio.h >  // librarie folosita pentru citire si scriere
# include < stdlib.h >  // librarie folosită pentru alocarea/dezalocarea pointerilor
# include < math.h >  // librarie folosita pentru diverse functii matematice

int  suma ( int x, int y) {
	întoarce x + y;
}

void  fct1 ( int &o) {
	o = 100 ;
}

void  fct2 ( int & o) {
	o = 200 ;
}

void  fct3 ( int & o) {
	o = 300 ;
}

// metoda bisectiei
// Sa se rezolve ecuatiile 1,2,3 prin metoda bisectiei

dublu  ecuatie1 ( dublu x) {
	return  3 * pow (x, 3 ) - 2 * pow (x, 2 ) + 10 * x + 30 ;
}

dublu  ecuatie2 ( dublu x) {
	returnează  3 * x - 9 ;
}

dublu  ecuatie3 ( dublu x) {
	return  3 * pow (x, 2 ) - 3 * x - 1 ;
}

void  metodaBisectiei ( double A, double B, int N,
	dublu (*ptr_ecuatie)( dublu ), dublu epsilon,
	double& solutie, int& cod) { // se pune "&" pentru ca variabile cod si solutie se modifica in acest bloc si vrem sa primim valorile modificate si in main()

	// A,B - capetele intervalului in care se cauta radacina unica

	// N-numarul maxim de pasi de cautare(daca nu gasti radicina in 1000 pasi te opresti...nu cauti la nesfarsit)

	// double(*ptr_ecuatie)(double) - pointer la functie -> folosita pentru a transmite mai departe din main() ecuatiile de mai sus (1,2,3)
	// daca va uitati atent pointerul la functie are acelasi format ca antetul functiilor de mai sus.

	// epsilon - eroarea acceptata - o variabila cat mai mica : 0.00001

	// solutie - se va salva in variabila solutie valoare radacinei
	// cod - poate fi 0 sau 1 ...-> 1 daca sa gasit radacina, 0 altfel.

	solutie = cod = 0 ;

	if ( ptr_ecuatie (A) == 0 ) { solutie = A; cod = 1 ; întoarcere ; } // aici se verifica daca partea inferioara a intervalului este radacina ecuatiei
	if ( ptr_ecuatie (B) == 0 ) { solutie = B; cod = 1 ; întoarcere ; } // aici se verifica daca partea superioara a intervalului este radacina ecuatiei
	if ( ptr_ecuatie (A) * ptr_ecuatie (B) > 0 ) {
		printf ( " Nu sa gasit nicio radacina sau s-au gasit prea multe \n " ); // aici e clar ce se intampla sper...
		cod = 0 ; întoarcere ;
	}
	while (N > 0 && cod == 0 ) { // /se itereaza in maxim N pasi sau pana cand se gaste radacina
		solutie = (A + B) / 2 ; // ne pozitionam la mijlocul intervalului [A,B]

		if ( ptr_ecuatie (solutie) == 0 ) { // daca valoarea mijlocului intervalului [A,B] este radacina atunci am gasit solutia.
			cod = 1 ; continua ;
		}

		if ( ptr_ecuatie (A) * ptr_ecuatie (solutie) < 0 ) { // daca nu sa gasit radacina mai sus atunci trebuie sa cautam alt interval
			B = solutie; // in cazul asta noul interval de cautare va fi [A,solutie] - (unde solutie era (A+B)/2)
		}
		else {
			A = solutie; // in cazul asta noul interval de cautare va fi [solutie, B] - (unde solutie era (A+B)/2)
		}

		if (B - A <= epsilon) { // se acceptă o radacina x in care f(x) sa tinda catre 0......
			cod = 1 ;
		}

		N--; // se trece la urmatorul pas. daca nu se gaste solutia in N pasi atunci codul ramane 0;
	}


}

void  main () {
	// un bit este valoarea 0 sau 1
	// 1 octet - 8 biți
	int x = 10 ; // var. intreaga - 4 bytes
	float y = 332,22 ; // var. reala - 4 octeți
	dublu z = 22,99 ; // var. reala - 8 octeți
	char w = ' a ' ; // var. caracter - 1 octet

	char sir[ 6 ] = { ' R ' , ' a ' , ' r ' , ' e ' , ' s ' , ' \0 ' }; // sir de caractere de 6 bytes

	const  int aa = 200 ; // var. constanta intreaga. nu mai poate fi modificat dupa initializare. - 4 octeți

	// %d = format de afisare pentru int
	// %lf = format de afisare pentru double
	// %f = format de afisare pentru float
	// %c = format de afisare pentru char
	// %p = format de afisare pentru pointeri/adrese
	// %s = format de afisare pentru un sir de caractere
	printf ( " Acesta este un mesaj \n " );
	printf ( " x=%d, y=%f, z=%.2lf, w=%c \n " , x, y, z, w);
	printf ( " domnule=%s \n " , domnule);
	printf ( " adresa variabilei x=%p \n " , &x);


	int var1 = 420 ;
	printf ( " var1=%d \n " , var1);
	fct1 (var1);
	printf ( " var1=%d \n " , var1);

	// pointeri
	printf ( " \n\n ---pointeri--- \n\n " );
	// sa presupunem ca variabila var1 se afla la adresa #22
	int * pointer1 = &var1; // variabila pointer este si ea creat la adresa de memorie #3 si are ca valoare #22
	printf ( " pointer1=%p \n " , pointer1);
	printf ( " *pointer1=%d \n " , *pointer1); // se numeste indirecte - adica se acceseaza zona de memorie salvata in pointer

	*pointer1 = *pointer1 + 20 ; // se numeste indirecte - adica se acceseaza zona de memorie salvata in pointer si se incrementeaza cu 20
	printf ( " *pointer1=%d \n " , *pointer1);
	printf ( " var1=%d \n " , var1);



	printf ( " \n\n ---pointeri la functii--- \n\n " );
	void (*pointerSpreFunctie)( int &);
	int uu = 11 ;

	pointerSpreFunctie = fct1;
	pointerSpreFunctie (uu);
	printf ( " pointerSpreFunctie a executat fct1(uu) si se afiseaza uu=%d \n " , uu);

	pointerSpreFunctie = fct2;
	pointerSpreFunctie (uu);
	printf ( " pointerSpreFunctie a executat fct2(uu) si se afiseaza uu=%d \n " , uu);

	pointerSpreFunctie = fct3;
	pointerSpreFunctie (uu);
	printf ( " pointerSpreFunctie a executat fct3(uu) si se afiseaza uu=%d \n " , uu);

	// int (*pointerSpreFunctie2)(int, int);
	// pointerSpreFunctie2 = suma;


	printf ( " \n\n ---metoda bisectiei--- \n\n " );

	// metoda bisectiei
	solutie dubla = 0 ;
	int cod = 0 ;
	metodaBisectiei (- 2 , 12 , 1000 , ecuatie1, 0.0001 , solutie, cod);
	printf ( " ecuatie 1: cod=%d, solutie=%.2lf \n " , cod, solutie);

	metodaBisectiei (- 2 , 12 , 1000 , ecuatie2, 0.0001 , solutie, cod);
	printf ( " ecuatie 2: cod=%d, solutie=%.2lf \n " , cod, solutie);

	metodaBisectiei (- 2 , 12 , 1000 , ecuatie3, 0.0001 , solutie, cod);
	printf ( " ecuatie 3: cod=%d, solutie=%.2lf \n " , cod, solutie);

}
SEMINAR 2
# include < stdio.h >
# include < șir.h >
# include < stdlib.h >

# pragma warning(disable:4996) // pentru a dezactiva _CRT_SECURE_NO_WARNINGS

enumerare CULORI {
	ALB,
	NEGRU = 10 ,
	VERDE = 20 ,
	ROSU,
	ROZ
};

const  char * transformaEnumInSirDeCaractere (CULORI x) {
	comutator (x)
	{
	cazul ALB:
		returnează  „ alb ” ;
	cazul NEGRU:
		return  „ negru ” ;
	cazul VERDE:
		return  " verde " ;
	cazul ROSU:
		return  " rosu " ;
	implicit :
		return  " culoarea introdusa nu a fost interpretata inca " ;
	}
}

CULORI transformaSirDeCaractereInEnum ( const  char * pointerSir) {
	if ( strcmp (pointerSir, " alb " ) == 0 ) {
		întoarce ALB;
	}
	else  if ( strcmp (pointerSir, " negru " ) == 0 ) {
		întoarce NEGRU;
	}
	else  if ( strcmp (pointerSir, " verde " ) == 0 ) {
		returnează VERDE;
	}
	else  if ( strcmp (pointerSir, " rosu " ) == 0 ) {
		intoarce ROSU;
	}

	return ROZ;
}

// 104 octeți
struct  client {
	char nume[ 100 ]; // 100 de octeți
	int varsta; // 4 octeți
};

// 100 de octeți
utilizator de sindicat
{
	int varsta; // 4 octeți
	char nume[ 100 ]; // 100 de octeți
	char gen; // 1 octet
};

struct  telefon {
	CULORI culoareTelefon;
	char * marca;
	dublu pret;
	int anFabricatie;
	versiunea char ;
	client proprietar;
};

void  scrieClientLaConsola (client c) {
	printf ( " client = %s \n " , c. nume );
	printf ( " varsta = %d \n\n " , c. varsta );
}

void  citesteClientDeLaConsola (client& c) {
	// uneori mai ramane blocat in buffer un \n
	// getchar(); folosit pt eliberare buffer (se citeste un caracter de la consola)
	printf ( " client = " );
	gets_s (c. nume );
	// scanf("%s", c.nume); //citeste pana la primul spatiu

	printf ( " varsta = " );
	scanf ( " %d " , etc. varsta );
}

void  scrieClientInFisierText (FILE* fisier, client c) {
	fprintf (fisier, " %s \n " , c. nume );
	fprintf (fisier, " %d \n " , c. varsta );
}

void  citireClientDinFisierText (FILE* fisier, client &c) {
	fgets (c. nume , 100 , fisier);
	fscanf (fisier, " %d " , etc. varsta );
}

void  scrieTelefonLaConsola (telefon t) {
	printf ( " culoare telefon = %s \n " , transformaEnumInSirDeCaractere (t. culoareTelefon ));

	printf ( " marca = %s \n " , t. marca );
	printf ( " pret = %.2lf \n " , t. pret );
	printf ( " an fabricatie = %d \n " , t. anFabricatie );
	printf ( " versiunea = %c \n " , versiunea t. );

	scrieClientLaConsola (t. proprietar );
	// linia de mai sus este echivalenta cu:
	// 	printf("client = %s\n", t.proprietar.nume);
	//   printf("varsta = %d\n\n", t.proprietar.varsta);
}
void  main () {
	// pentru a declara un sir de caracter pe stack ai face asa: char aux[100];
	// unde aux este o variabila care are ca valoare adresa primului element din vector...adica aux[0]
	// si ca sa pui ceva in aux: strcpy(aux,"un sir de caractere oarecare");

	printf ( " %s \n " , transformaEnumInSirDeCaractere (ROZ));
	printf ( " %d \n " , transformaSirDeCaractereInEnum ( " verdreagergee " ));

	client c1;
	c1. varsta = 30 ;
	strcpy (c1. nume , " Ion Popescu " );

	utilizator u1;
	u1. varsta = 20 ;
	printf ( " u1.varsta=%d \n " , u1. varsta );
	strcpy (u1. nume , " Ana Popescu " );
	printf ( " u1.nume=%s \n " , u1. nume );
	printf ( " u1.varsta=%d \n " , u1. varsta );
	u1. varsta = 30 ;
	u1. gen = ' D ' ;
	printf ( " u1.gen=%c \n " , u1. gen );
	printf ( " u1.varsta=%d \n " , u1. varsta );


	// scriere in fisiere
	// w-creare fisier si scriere in el, daca exista fisierul exista se sterg toate informatiile din el
	// wb-este "w" în mod binar
	// r-citire din fisier, daca fisierul nu exista se intoarce NULL la fopen()
	// rb-este "r" in mod binar, daca fisierul nu exista se intoarce NULL la fopen()
	// a-adaugare informatii la sf fisierului, daca NU exista fisierul se face unul nou
	// ab- este "a" în mod binar
	// r+ sau rb+ - fisier deschis pentru citire si scriere/ citire si scriere in mod binar, daca fisierul nu exista se intoarce NULL la fopen()
	// w+ sau wb+ - fisier deschis pentru citire si scriere in mod binar.
	// a+ si ab+ - fisier deschis pentru citire si adaugare la final

	FILE* fisierClienti = fopen ( " clienti.txt " , " w " );
	if (fisierClienti == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru scrierea fisierului clienti.txt " );
		ieșire ( 1000 );
	}

	client c2;
	c2. varsta = 20 ;
	strcpy (c2. nume , " Laurentiu Popescu " );

	client c3;
	citesteClientDeLaConsola (c3);

	printf ( " \n\n ----SCRIERE CLIENT LA CONSOLA---- \n\n " );
	scrieClientLaConsola (c1);
	scrieClientLaConsola (c2);
	scrieClientLaConsola (c3);

	printf ( " \n\n ----CLIENT SCRIERE ÎN TEXT FISIER---- \n\n " );

	scrieClientInFisierText (fisierClienti, c1);
	scrieClientInFisierText (fisierClienti, c2);
	scrieClientInFisierText (fisierClienti, c3);
	fclose (fisierClienti);

	printf ( " \n\n ----CITIRE CLIENT DIN FISIER TEXT---- \n\n " );
	fisierClienti = fopen ( " clienti.txt " , " r " );
	if (fisierClienti == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru citire fisierul clienti.txt " );
		ieșire ( 2000 );
	}
	client c4, c5, c6;
	citireClientDinFisierText (fisierClienti, c4);
	fgetc (fisierClienti); // pentru a elibera buffer-ul de \n
	citireClientDinFisierText (fisierClienti, c5);
	fgetc (fisierClienti); // pentru a elibera buffer-ul de \n
	citireClientDinFisierText (fisierClienti, c6);
	scrieClientLaConsola (c4);
	scrieClientLaConsola (c5);
	scrieClientLaConsola (c6);

	fclose (fisierClienti);

	printf ( " \n\n ----SCRIE TELEFON LA CONSOLA---- \n\n " );
	telefon t1, t2, t3;
	t1. anFabricatie = 2021 ;
	t2. anFabricatie = 2022 ;

	t1. culoareTelefon = VERDE;
	t2. culoareTelefon = NEGRU;

	t1. pret = 2600,99 ;
	t2. pret = 3599,99 ;

	t1. versiune = ' X ' ;
	t2. versiune = ' 8 ' ;

	t1. proprietar = c1;
	t2. proprietar = c2;

	// pt alocare memorie pe heap:
	// 1) aloci memorie
	t1. marca = ( char *) malloc ( strlen ( " Apple " ) + 1 ); // se aloca memorie pe heap pt 6 bytes : 5+1 - unde +1 este acel \0
	// 2) copiezi informatia la acea zona de memorie
	strcpy (t1. marca , " Apple " );

	t2. marca = ( char *) malloc ( strlen ( " Huawei " ) + 1 );
	strcpy (t2. marca , " Huawei " );

	scrieTelefonLaConsola (t1);
	scrieTelefonLaConsola (t2);


}
SEMINAR 3
# include < stdio.h >
# include < șir.h >
# include < stdlib.h >

# pragma warning(disable:4996) // pentru a dezactiva _CRT_SECURE_NO_WARNINGS

enumerare CULORI {
	ALB,
	NEGRU = 10 ,
	VERDE = 20 ,
	ROSU,
	ROZ
};

const  char * transformaEnumInSirDeCaractere (CULORI x) {
	comutator (x)
	{
	cazul ALB:
		returnează  „ alb ” ;
	cazul NEGRU:
		return  „ negru ” ;
	cazul VERDE:
		return  " verde " ;
	cazul ROSU:
		return  " rosu " ;
	implicit :
		returnează  " implicit " ;
	}
}

CULORI transformaSirDeCaractereInEnum ( const  char * pointerSir) {
	if ( strcmp (pointerSir, " alb " ) == 0 ) {
		întoarce ALB;
	}
	else  if ( strcmp (pointerSir, " negru " ) == 0 ) {
		întoarce NEGRU;
	}
	else  if ( strcmp (pointerSir, " verde " ) == 0 ) {
		returnează VERDE;
	}
	else  if ( strcmp (pointerSir, " rosu " ) == 0 ) {
		intoarce ROSU;
	}

	return ROZ;
}

// 104 octeți
struct  client {
	char nume[ 100 ]; // 100 de octeți
	int varsta; // 4 octeți
};

// 100 de octeți
utilizator de sindicat
{
	int varsta; // 4 octeți
	char nume[ 100 ]; // 100 de octeți
	char gen; // 1 octet
};

struct  telefon {
	CULORI culoareTelefon;
	char * marca;
	dublu pret;
	int anFabricatie;
	versiunea char ;
	client proprietar;
};

void  scrieClientLaConsola (client c) {
	printf ( " client = %s \n " , c. nume );
	printf ( " varsta = %d \n " , c. varsta );
}

void  citesteClientDeLaConsola (client& c) {
	// uneori mai ramane blocat in buffer un \n
	// getchar(); folosit pt eliberare buffer (se citeste un caracter de la consola)
	printf ( " client = " );
	gets_s (c. nume );
	// scanf("%s", c.nume); //citeste pana la primul spatiu

	printf ( " varsta = " );
	scanf ( " %d " , etc. varsta );
}

void  scrieClientInFisierText (FILE* fisier, client c) {
	fprintf (fisier, " %s \n " , c. nume );
	fprintf (fisier, " %d \n " , c. varsta );
}

void  citireClientDinFisierText (FILE* fisier, client& c) {
	fgets (c. nume , 100 , fisier);
	c. nume [ strcspn (c. nume , " \n " )] = 0 ; // se va inlocui \n cu 0 - adica sfarsit de sir de caractere
	fscanf (fisier, " %d " , etc. varsta );
}

void  scrieTelefonLaConsola (telefon t) {
	printf ( " culoare telefon = %s \n " , transformaEnumInSirDeCaractere (t. culoareTelefon ));

	printf ( " marca = %s \n " , t. marca );
	printf ( " pret = %.2lf \n " , t. pret );
	printf ( " an fabricatie = %d \n " , t. anFabricatie );
	printf ( " versiunea = %c \n " , versiunea t. );

	scrieClientLaConsola (t. proprietar );
	// linia de mai sus este echivalenta cu:
	// 	printf("client = %s\n", t.proprietar.nume);
	//   printf("varsta = %d\n\n", t.proprietar.varsta);
}

void  citireTelefonDeLaConsola (telefon& t) {
	char aux[ 100 ];
	printf ( " culoare telefon (alb / negru / verde / rosu / roz) = " );
	scanf ( " %s " , aux);
	t. culoareTelefon = transformaSirDeCaractereInEnum (aux);

	printf ( " marca = " );
	scanf ( " %s " , aux);
	t. marca = ( char *) malloc ( strlen (aux) + 1 ); // +1 este pt \0
	strcpy (t. marca , aux);

	printf ( " pret= " );
	scanf ( " %lf " , &t. pret );

	printf ( " an fabricatie= " );
	scanf ( " %d " , &t. anFabricatie );


	printf ( " versiune= " );
	scanf ( " %c " , &t. versiunea ); // daca tu introduci de la tastatura pt an fabricatie 2020 (in spate inseamna 2020\n) =>
	// automat t.version=\n ...ca sa evitam aceasta problema (sa ignore acel \n) punem un spatiu inainte de %c

	getchar (); // folosit pt a elibera bufferul...cand citesti versiunea ( se citeste de fapt de ex: 9\n) => ramane in buffer \n

	citesteClientDeLaConsola (t. proprietar );
}

void  scrieTelefonInFisierText (FILE* fisier, telefon t) {
	fprintf (fisier, " %s \n " , transformaEnumInSirDeCaractere (t. culoareTelefon ));

	fprintf (fisier, " %s \n " , t. marca );
	fprintf (fisier, " %.2lf \n " , t. pret );
	fprintf (fisier, " %d \n " , t. anFabricatie );
	fprintf (fisier, " %c \n " , versiunea t. );

	scrieClientInFisierText (fisier, t. proprietar );
}

void  citireTelefonDinFisierText (FILE* fisier, telefon& t) {
	char aux[ 100 ];
	fscanf (fisier, " %s " , aux);
	t. culoareTelefon = transformaSirDeCaractereInEnum (aux);

	fscanf (fisier, " %s " , aux);
	t. marca = ( char *) malloc ( strlen (aux) + 1 ); // +1 este pt \0
	strcpy (t. marca , aux);

	fscanf (fisier, " %lf " , &t. pret );

	fscanf (fisier, " %d " , &t. anFabricatie );


	fscanf (fisier, " %c " , &t. versiune ); // daca tu introduci de la tastatura pt an fabricatie 2020 (in spate inseamna 2020\n) =>
	// automat t.version=\n ...ca sa evitam aceasta problema (sa ignore acel \n) punem un spatiu inainte de %c

	fgetc (fisier); // folosit pt a elibera bufferul...cand citesti versiunea ( se citeste de fapt de ex: 9\n) => ramane in buffer \n

	citireClientDinFisierText (fisier, t. proprietar );
}

void  scrieClientInFisierBinar (FILE* fisier, client c) {
	// functia fwrite - primeste ca input ===> fwrite(addressData, sizeData, numbersData, pointerToFile);
	// addressData - adresa variabilei citite (cu "&" in fata)
	// sizeData - dimensiunea variabilei salvate (sizeof)
	// numbersData - numărul de variabile salvate
			// int arr[3] = {101, 203, 303};
			// 
			// fwrite(arr, sizeof(int), 2, fp); //va scrie primele 2 elemente din vector
	// pointerToFile - fisierul unde se salveaza variabila

	// DACA scrierea are erori atunci fwrite va retuna un număr mai mic decat variabila numbersData;

	// fwrite(&t, sizeof(l), 1, fisier); //Daca clientul nu ar fi avut char* puteam sa scriem direct asa.

	// fwrite(&c, sizeof(c), 1, fisier);// <-echivalentul a ce am scris mai jos

	int dim = strlen (c. nume ) + 1 ;
	fwrite (&dim, sizeof (dim), 1 , fisier);
	fwrite (&c. nume , dim, 1 , fisier);

	fwrite (&c. varsta , sizeof (c. varsta ), 1 , fisier);
}

void  citireClientDinFisierBinar (FILE* fisier, client &c) {
	// functia fread - primeste ca input===> fread(addressData, sizeData, numbersData, pointerToFile);
	// descrierea parametrilor este la fel ca la fwrite

	// fread(&l, sizeof(l), 1, fisier); //daca nu aveam char* in structura client scriam asa.

	// fread(&c, sizeof(c), 1, fisier);// <-echivalentul a ce am scris mai jos
	int dim = 0 ;
	fread (&dim, sizeof (dim), 1 , fisier);
	fread (&c. nume , dim, 1 , fisier);

	fread (&c. varsta , sizeof (c. varsta ), 1 , fisier);
}

void  scrieTelefonInFisierBinar (FILE* fisier, telefon t) {
	char aux[ 100 ];
	strcpy (aux, transformaEnumInSirDeCaractere (t. culoareTelefon ));

	int dim = strlen (aux) + 1 ; // calculam dim culorii +1 (pt \0)
	fwrite (&dim, sizeof (dim), 1 , fisier);
	fwrite (aux, dim, 1 , fisier);

	dim = strlen (t. marca ) + 1 ; // calculam dim marcii +1 (pt \0)
	fwrite (&dim, sizeof (dim), 1 , fisier);
	fwrite (t. marca , dim, 1 , fisier);

	fwrite (&t. pret , sizeof (t. pret ), 1 , fisier);

	fwrite (&t. anFabricatie , sizeof (t. anFabricatie ), 1 , fisier);

	fwrite (&t. versiunea , sizeof (t. versiunea ), 1 , fisier);

	scrieClientInFisierBinar (fisier, t. proprietar );
}

void  citireTelefonDinFisierBinar (FILE* fisier, telefon &t) {
	char aux[ 100 ];
	int dim = 0 ;
	fread (&dim, sizeof (dim), 1 , fisier);
	fread (aux, dim, 1 , fisier);
	t. culoareTelefon = transformaSirDeCaractereInEnum (aux);


	fread (&dim, sizeof (dim), 1 , fisier);
	fread (aux, dim, 1 , fisier);
	t. marca = ( char *) malloc ( strlen (aux) + 1 ); // +1 pt \0
	strcpy (t. marca , aux);

	fread (&t. pret , sizeof (t. pret ), 1 , fisier);

	fread (&t. anFabricatie , sizeof (t. anFabricatie ), 1 , fisier);

	fread (&t. versiunea , sizeof (t. versiunea ), 1 , fisier);

	citireClientDinFisierBinar (fisier, t. proprietar );
}

void  main () {
	// pentru a declara un sir de caracter pe stack ai face asa: char aux[100];
	// unde aux este o variabila care are ca valoare adresa primului element din vector...adica aux[0]
	// si ca sa pui ceva in aux: strcpy(aux,"un sir de caractere oarecare");

	printf ( " %s \n " , transformaEnumInSirDeCaractere (ROZ));
	printf ( " %d \n " , transformaSirDeCaractereInEnum ( " verdreagergee " ));

	client c1;
	c1. varsta = 30 ;
	strcpy (c1. nume , " Ion Popescu " );

	utilizator u1;
	u1. varsta = 20 ;
	printf ( " u1.varsta=%d \n " , u1. varsta );
	strcpy (u1. nume , " Ana Popescu " );
	printf ( " u1.nume=%s \n " , u1. nume );
	printf ( " u1.varsta=%d \n " , u1. varsta );
	u1. varsta = 30 ;
	u1. gen = ' D ' ;
	printf ( " u1.gen=%c \n " , u1. gen );
	printf ( " u1.varsta=%d \n " , u1. varsta );


	// scriere in fisiere
	// w-creare fisier si scriere in el, daca exista fisierul exista se sterg toate informatiile din el
	// wb-este "w" în mod binar
	// r-citire din fisier, daca fisierul nu exista se intoarce NULL la fopen()
	// rb-este "r" in mod binar, daca fisierul nu exista se intoarce NULL la fopen()
	// a-adaugare informatii la sf fisierului, daca NU exista fisierul se face unul nou
	// ab- este "a" în mod binar
	// r+ sau rb+ - fisier deschis pentru citire si scriere/ citire si scriere in mod binar, daca fisierul nu exista se intoarce NULL la fopen()
	// w+ sau wb+ - fisier deschis pentru citire si scriere in mod binar.
	// a+ si ab+ - fisier deschis pentru citire si adaugare la final

	FILE* fisierClienti = fopen ( " clienti.txt " , " w " );
	if (fisierClienti == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru scrierea fisierului clienti.txt " );
		ieșire ( 1000 );
	}

	client c2;
	c2. varsta = 20 ;
	strcpy (c2. nume , " Laurentiu Popescu " );

	client c3;
	citesteClientDeLaConsola (c3);

	printf ( " \n\n ----SCRIERE CLIENT LA CONSOLA---- \n\n " );
	scrieClientLaConsola (c1);
	scrieClientLaConsola (c2);
	scrieClientLaConsola (c3);

	printf ( " \n\n ----CLIENT SCRIERE ÎN TEXT FISIER---- \n\n " );

	scrieClientInFisierText (fisierClienti, c1);
	scrieClientInFisierText (fisierClienti, c2);
	scrieClientInFisierText (fisierClienti, c3);
	fclose (fisierClienti);

	printf ( " \n\n ----CITIRE CLIENT DIN FISIER TEXT---- \n\n " );
	fisierClienti = fopen ( " clienti.txt " , " r " );
	if (fisierClienti == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru citire fisierul clienti.txt " );
		ieșire ( 2000 );
	}
	client c4, c5, c6;
	citireClientDinFisierText (fisierClienti, c4);
	fgetc (fisierClienti); // pentru a elibera buffer-ul de \n
	citireClientDinFisierText (fisierClienti, c5);
	fgetc (fisierClienti); // pentru a elibera buffer-ul de \n
	citireClientDinFisierText (fisierClienti, c6);
	scrieClientLaConsola (c4);
	scrieClientLaConsola (c5);
	scrieClientLaConsola (c6);

	fclose (fisierClienti);

	printf ( " \n\n ----CITIRE TELEFON DE LA CONSOLA---- \n\n " );

	telefon t1, t2, t3;
	t1. anFabricatie = 2021 ;
	t2. anFabricatie = 2022 ;

	t1. culoareTelefon = VERDE;
	t2. culoareTelefon = NEGRU;

	t1. pret = 2600,99 ;
	t2. pret = 3599,99 ;

	t1. versiune = ' X ' ;
	t2. versiune = ' 8 ' ;

	t1. proprietar = c1;
	t2. proprietar = c2;

	// pt alocare memorie pe heap:
	// 1) aloci memorie
	t1. marca = ( char *) malloc ( strlen ( " Apple " ) + 1 ); // se aloca memorie pe heap pt 6 bytes : 5+1 - unde +1 este acel \0
	// 2) copiezi informatia la acea zona de memorie
	strcpy (t1. marca , " Apple " );

	t2. marca = ( char *) malloc ( strlen ( " Huawei " ) + 1 );
	strcpy (t2. marca , " Huawei " );



	citireTelefonDeLaConsola (t3);


	printf ( " \n\n ----SCRIE TELEFON LA CONSOLA---- \n\n " );
	scrieTelefonLaConsola (t1);
	printf ( " \n " );
	scrieTelefonLaConsola (t2);
	printf ( " \n " );
	scrieTelefonLaConsola (t3);

	printf ( " \n\n ----SCRIE TELEFON IN FISIER TEXT---- \n\n " );
	FILE* fisierTelefoane = fopen ( " telefoane.txt " , " w " );
	if (fisierClienti == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru scrierea fisierului telefoane.txt " );
		ieșire ( 900 );
	}

	scrieTelefonInFisierText (fisierTelefoane, t1);
	scrieTelefonInFisierText (fisierTelefoane, t2);
	scrieTelefonInFisierText (fisierTelefoane, t3);


	fclose (fisierTelefoane);
	
	printf ( " \n\n ----CITIRE TELEFON DIN FIISER TEXT---- \n\n " );
	fisierTelefoane = fopen ( " telefoane.txt " , " r " );
	if (fisierClienti == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru citire fisierul telefoane.txt " );
		ieșire ( 330 );
	}

	telefon t4, t5, t6;

	citireTelefonDinFisierText (fisierTelefoane, t4);
	citireTelefonDinFisierText (fisierTelefoane, t5);
	citireTelefonDinFisierText (fisierTelefoane, t6);

	scrieTelefonLaConsola (t4);
	scrieTelefonLaConsola (t5);
	scrieTelefonLaConsola (t6);


	fclose (fisierTelefoane);

	printf ( " \n\n ----SCRIE TELEFON IN FISIER BINAR---- \n\n " );
	FIȘIER *fisierTelefoaneBinar = fopen ( " telefoaneBinar.bin " , " wb " );
	if (fisierTelefoaneBinar == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru scrierea fisierului telefoaneBinar.bin " );
		ieșire ( 530 );
	}
	scrieTelefonInFisierBinar (fisierTelefoaneBinar, t4);	
	scrieTelefonInFisierBinar (fisierTelefoaneBinar, t5);
	scrieTelefonInFisierBinar (fisierTelefoaneBinar, t6);

	fclose (fisierTelefoaneBinar);

	printf ( " \n\n ----CITIRE TELEFON DIN FIISER BINAR---- \n\n " );

	fisierTelefoaneBinar = fopen ( " telefoaneBinar.bin " , " rb " );
	if (fisierTelefoaneBinar == NULL ) {
		printf ( " Eroare: Nu sa putut deschide pentru citire fisierul telefoaneBinar.bin " );
		ieșire ( 730 );
	}

	telefon t10, t11, t12;
	citireTelefonDinFisierBinar (fisierTelefoaneBinar, t10);
	citireTelefonDinFisierBinar (fisierTelefoaneBinar, t11);
	citireTelefonDinFisierBinar (fisierTelefoaneBinar, t12);
	

	scrieTelefonLaConsola (t10);
	printf ( " \n " );
	scrieTelefonLaConsola (t11);
	printf ( " \n " );
	scrieTelefonLaConsola (t12);

	fclose (fisierTelefoaneBinar);

	liber (t1. marca );
	liber (t2. marca );
	liber (t3. marca );
	liber (t4. marca );
	liber (t5. marca );
	liber (t6. marca );
	gratuit (t10. marca );
	liber (t11. marca );
	liber (t12. marca );
}
SEMINAR 4
// rewind(f) -> te repozitionezi la inceputul fisierului.

# include < stdio.h >
# include < stdlib.h >

# avertisment pragma (disable:4996)

// 140 de octeți
struct  Animal {
	cheie int ;
	char denumire[ 100 ];
	int varsta;
	dubla greutate;
	char culoare[ 20 ];
	int esteSetat; // pentru a indica daca o locatie din fisier este ocupata de un animal
};

void  afisareAnimal (Animal a) {
	printf ( " Cheie=%d \n " , a. cheie );
	printf ( " Denumire=%s \n " , a. Denumire );
	printf ( " Varsta=%d \n " , a. varsta );
	printf ( " Greutate=%2.lf \n " , a. greutate );
	printf ( " Culoare=%s \n " , a. culoare );
	printf ( " EsteSetat=%d \n " , a. esteSetat );
}

void  citireAnimal (Animal& a) {
	printf ( " Denumire = " ); scanf ( " %s " , a. denumire );
	printf ( " Varsta = " ); scanf ( " %d " , &a. varsta );
	printf ( " Greutate = " ); scanf ( " %lf " , &a. greutate );
	printf ( " Culoare = " ); scanf ( " %s " , a. culoare );
	A. esteSetat = 1 ;
}

int  aflaCateAnimaleSuntInFiser (FILE* f) {
	// ftell -> returneaza pozitia curenta a cursorului in fisier
	int pozCurenta = ftell (f); // pasram pozita curenta;

	fseek (f, 0 , SEEK_END); // se pozitioneaza la sf fisierului

	int nrAnimale = ftell (f) / sizeof (Animal); // daca tu ai 4 animale in fisier=> ftell va fi 560 => 560/140 = 4 animale

	fseek (f, pozCurenta, SEEK_SET); // se pozitioneaza la pozitia initiala

	return nrAnimale;
}

void  main () {
	// Afisarea informatiilor in format tabel

	// FIȘIER *f = fopen("ceva.txt", "w");
	// fprintf(f, „%4s %-16s %3s %30s”, „Crt.”, „BBB”, „AAAA”, „Suma”);
	// printf("%4s %-16s %3s %30s", "Crt.", "BBB", "AAAA", "Suma");

	// fclose(f);


	// long int ftell(FIȘIER *fp); - returneaza pozitia curenta;

	// int fseek(FILE *fp, long int offset, int origine);

	// fp - fisierul peste care se aplica operatia fseek;

	// offset - numărul de bytes fata de origine(al 3 lea parametru);
	// poate fi nr. pozitiv(pt mersul înainte prin fisier) sau negativ(pt mersul inapoi prin fisier);

	// origine - originea punctului fata de care se aplica offsetul;
	// Ex: SEEK_SET - inceputul fisierului
	// Ex: SEEK_CUR - pozitia curenta a fisierului
	// Ex: SEEK_END - sfarsitul fisierului

	// fseek - returneaza 0 daca mutarea a fost efectuata cu succes, altfel o alta val !=0


	FILE* fisBinar = fopen ( " fisBinarAnimale.bin " , " wb+ " );
	if (fisBinar == NULL ) {
		printf ( " ERROR: fisBinarAnimale.bin nu sa putut deschide. " );
		ieșire ( 1 );
	}


	while (! feof (stdin)) { // atunci cand se cere ca sfarsitul introducerii sa fie marcat standard
		printf ( " \n\n Alegeti o optiune din meniu: \n " );
		printf ( " 1) Salvati un animal in fisier la o anumita pozitie. \n " );
		printf ( " 2) Modificati un animal din fisier de la o anumita pozitie. \n " );
		printf ( " 3) Stergeti un animal din fisier de la o anumita pozitie. \n " );
		printf ( " 4) Afisati un animal din fisier de la o anumita pozitie. \n " );
		printf ( " 5) Ieșire. \n " );

		int optiune;
		printf ( " Introduceti optiunea dorita: " ); scanf ( " %d " , &optiune);

		comutator (opțiune)
		{
		cazul  1 :
		{
			cheie int ;
			printf ( " Introduceti un animal de la tastatura: \n " );
			printf ( " Cheie: " ); scanf ( " %d " , &key);
			int nrAnimale = aflaCateAnimaleSuntInFiser (fisBinar);

			dacă (cheie >= 0 ) {
				Animal x;
				if (cheie >= nrAnimale) {
					// alocam memorie noua daca cheia introdusa > nr de animale din fisier

					X. esteSetat = 0 ;

					fseek (fisBinar, 0 , SEEK_END); // cand fis e gol si te pozitionezi la sf => te pozitionezi la inceputul fisierului.

					pentru ( int i = 0 ; i < ( cheie + 1 ) - nrAnimale; i++) {
						fwrite (&x, sizeof (Animal), 1 , fisBinar);
					}
				}

				// se poziționează cursorul la adresa key * sizeof(Animal)
				fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

				// se citeste animalul de la adreasa: key * sizeof(Animal)
				fread (&x, sizeof (Animal), 1 , fisBinar);

				if (x. esteSetat == 1 ) {
					printf ( " La cheia introdusa exista deja un animal salvat. Nu se mai poate adauga unul. \n " );
				}
				else {
					X. cheie = cheie;
					citireAnimal (x);

					// se poziționează cursorul la adresa key * sizeof(Animal)
					fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

					// se scrie Animalul in fisier la adresa key * sizeof(Animal)
					fwrite (&x, sizeof (Animal), 1 , fisBinar);

				}
			}

			rupe ;
		}
		cazul  2 : {
			Animal x;
			cheie int ;
			printf ( " Cheie: " ); scanf ( " %d " , &key);

			// se poziționează cursorul la adresa key * sizeof(Animal)
			fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

			// se citeste animalul de la adreasa: key * sizeof(Animal)
			fread (&x, sizeof (Animal), 1 , fisBinar);

			if (x. esteSetat == 0 ) {
				printf ( " La cheia introdusa nu exista niciun animal. NU se poate modifica nimic. \n " );
			}
			else {
				citireAnimal (x);

				// se poziționează cursorul la adresa key * sizeof(Animal)
				fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

				// se scrie Animalul in fisier la adresa key * sizeof(Animal)
				fwrite (&x, sizeof (Animal), 1 , fisBinar);

			}

			rupe ;
		}
		cazul  3 : {
			Animal x;
			cheie int ;
			printf ( " Cheie: " ); scanf ( " %d " , &key);


			// se poziționează cursorul la adresa key * sizeof(Animal)
			fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

			// se citeste animalul de la adreasa: key * sizeof(Animal)
			fread (&x, sizeof (Animal), 1 , fisBinar);

			if (x. esteSetat == 0 ) {
				printf ( " La cheia introdusa nu exista niciun animal. NU se poate sterge nimic. \n " );
			}
			else {
				X. esteSetat = 0 ;

				// se poziționează cursorul la adresa key * sizeof(Animal)
				fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

				// se scrie Animalul in fisier la adresa key * sizeof(Animal)
				fwrite (&x, sizeof (Animal), 1 , fisBinar);

				printf ( " Sa sters animalul de la cheia: %d \n " , key);
			}

			rupe ;
		}
		cazul  4 : {
			Animal x;
			cheie int ;
			printf ( " Cheie: " ); scanf ( " %d " , &key);

			// se poziționează cursorul la adresa key * sizeof(Animal)
			fseek (fisBinar, cheie * sizeof (Animal), SEEK_SET);

			// se citeste animalul de la adreasa: key * sizeof(Animal)
			fread (&x, sizeof (Animal), 1 , fisBinar);

			if (x. esteSetat == 0 ) {
				printf ( " La cheia introdusa nu exista niciun animal. NU se poate afisa nimic. \n " );
			}
			else {
				afisareAnimal (x);
			}

			rupe ;
		}
		cazul  5 :
		{
			printf ( " Aplicatia sa oprit. \n " );
			ieșire ( 44 );
		}
		implicit :
			printf ( " Optiunea introducesa nu exista. \n " );
		}
	}
}
SEMINAR 5 EX 1
# include < stdio.h >
# include < stdlib.h >
# include < șir.h >
# avertisment pragma (dezactivare:4996)

// fisier binar relativ
typedef  struct {
	char este;
	cod int ; // is si cod reprezinta informatiile vitale la folosirea fis. binare relative
	char nume[ 30 ];
	char prenume[ 30 ];
	char dep[ 20 ];
	char prof[ 20 ];
	int varsta;
	float sal[ 3 ];
	 date struct {
		int zi;
		int luna;
		int an;
	} data_ang;
} ang;

int  nr_art (FILE* f)
{
	int l, m;

	l = ftell (f); // poz curenta
	fseek (f, 0 , SEEK_END); // te duce la finalul fisierului

	m = ftell (f) / sizeof (ang);

	fseek (f, l, 0 ); // ma repozitionez de unde am plecat
	întoarce m;
}

void  populare ()
{
	DOSAR* f;

	ang a;
	int n, i, er;
	char nume_f[ 20 ];

	printf ( " \n nume fisier: " );
	gets_s (număr_f);
	f = fopen (număr_f, " wb+ " );

	printf ( " n= " ); scanf_s ( " %d " , &n); // reprezintă codul
	while (! feof (stdin)) // <----sfarsitul introducerii fiind marcat standard - se citeste pana cand introduceti CTRL+Z
	{
		// aici n >= 1
		if (n > nr_art (f)) // / A1 A2 A3 A4 ..........A300
		{
			fseek (f, 0 , SEEK_END);
			A. este = 0 ;
			pentru (i = nr_art (f); i < n; i++)
				fwrite (&a, sizeof (ang), 1 , f);

			A. este = 1 ;
			A. cod = n;
			printf ( " nume= " ); getc (stdin); gets_s (a. nume );
			printf ( " prenume= " ); gets_s (a. prenume );
			printf ( " dep= " ); gets_s (a. dep );
			printf ( " prof= " ); gets_s (a. prof );
			printf ( " varsta= " ); scanf_s ( " %d " , &a. varsta );
			pentru (i = 0 ; i < 3 ; i++)
			{
				printf ( " sal din luna %d: " , i + 1 );
				scanf_s ( " %f " , &a. sal [i]);
			}
			printf ( " data angajarii zi, luna si an:   " ); // 03 05 2019
			scanf ( " %d %d %d " , &a. data_ang . zi , &a. data_ang . luna , &a. data_ang . an );
			fseek (f, (n - 1 ) * sizeof (ang), 0 ); // atentie aici....e (n-1)....daca n=1 => 0*sizeof(ang) ...adica ne pozitionam la byte-ul 0
			fwrite (&a, sizeof (ang), 1 , f);
		}
		else {
			fseek (f, (n - 1 ) * sizeof (ang), 0 );
			fread (&a, sizeof (ang), 1 , f);
			dacă (a. este == 0 ) {
				A. este = 1 ;
				A. cod = n;
				printf ( " nume= " ); getc (stdin); gets_s (a. nume );
				printf ( " prenume= " ); gets_s (a. prenume );
				printf ( " dep= " ); gets_s (a. dep );
				printf ( " prof= " ); gets_s (a. prof );
				printf ( " varsta= " ); scanf_s ( " %d " , &a. varsta );
				pentru (i = 0 ; i < 3 ; i++)
				{
					printf ( " sal din luna %d: " , i + 1 );
					scanf_s ( " %f " , &a. sal [i]);
				}
				printf ( " data angajaraii zi, luna si an: " );
				scanf ( " %d %d %d " , &a. data_ang . zi , &a. data_ang . luna , &a. data_ang . an );
				fseek (f, (n - 1 ) * sizeof (ang), 0 ); // repozitionare pentru ca dupa fseek-ul de la linia 75 este un fread care va trece
				// la urmatorul angajat din fisier
				fwrite (&a, sizeof (ang), 1 , f);
			}
			else  printf ( " inreg. exista \n " );
		}
		printf ( " \n n= " ); scanf_s ( " %d " , &n);
	}
	fclose (f);
}

void  adaugare ()
{
	DOSAR* f;
	ang a;
	int n, i, er;
	char nume_f[ 20 ];
	int nr = sizeof (ang);

	printf ( " \n nume fisier: " );
	gets_s (număr_f);
	f = fopen (număr_f, " rb+ " ); // va deschide fisierul in format de citire si scriere....dar ce exista in fisier se pastreaza

	if (f == NULL ) f = fopen (număr_f, " wb+ " );
	printf ( " \n n= " ); scanf_s ( " %d " , &n);

	în timp ce (! feof (stdin))
	{
		if (n > nr_art (f))
		{
			fseek (f, 0 , 2 );
			A. este = 0 ;
			pentru (i = nr_art (f); i < n; i++)
				fwrite (&a, sizeof (ang), 1 , f);
			fseek (f, (n - 1 ) * sizeof (ang), 0 );
			A. este = 1 ;
			A. cod = n;
			printf ( " nume= " ); getc (stdin); gets_s (a. nume );
			printf ( " prenume= " ); gets_s (a. prenume );
			printf ( " dep= " ); gets_s (a. dep );
			printf ( " prof= " ); gets_s (a. prof );
			printf ( " varsta= " ); scanf_s ( " %d " , &a. varsta );
			pentru (i = 0 ; i < 3 ; i++)
			{
				printf ( " sal din luna %d: " , i + 1 );
				scanf_s ( " %f " , &a. sal [i]);
			}
			printf ( " data angajarii zi, luna si an: " );
			scanf ( " %d %d %d " , &a. data_ang . zi , &a. data_ang . luna , &a. data_ang . an );
			fwrite (&a, sizeof (ang), 1 , f);
		}
		else {
			fseek (f, (n - 1 ) * sizeof (ang), 0 );
			fread (&a, sizeof (ang), 1 , f);
			dacă (a. este == 0 ) {
				A. este = 1 ;
				A. cod = n;
				printf ( " nume= " ); getc (stdin); gets_s (a. nume );
				printf ( " prenume= " ); gets_s (a. prenume );
				printf ( " dep= " ); gets_s (a. dep );
				printf ( " prof= " ); gets_s (a. prof );
				printf ( " varsta= " ); scanf_s ( " %d " , &a. varsta );
				pentru (i = 0 ; i < 3 ; i++)
				{
					printf ( " sal din luna %d: " , i + 1 );
					scanf_s ( " %f " , &a. sal [i]);
				}
				printf ( " data angajarii zi, luna si an: " );
				scanf ( " %d %d %d " , &a. data_ang . zi , &a. data_ang . luna , &a. data_ang . an );
				fseek (f, (n - 1 ) * sizeof (ang), 0 );
				// fseek(f, ftell(f) - sizeof(ang), 1);
				fwrite (&a, sizeof (ang), 1 , f);
			}
			else  printf ( " inregistrarea exista \n " );
		}
		printf ( " \n n= " ); scanf_s ( " %d " , &n);
	}
	fclose (f);
}
void  afisare ()
{
	DOSAR* f, * g;
	ang a;
	char nume_f[ 20 ];
	printf ( " \n nume fisier: " );
	gets_s (număr_f);
	if (!(f = fopen (nume_f, " rb " ))) printf ( " nu exista fisierul " );
	else {
		printf ( " \n ===========================afisarea inregistrarilor din fisier============= " );
		g = fopen ( " lista_fis.txt " , " w " );
		printf ( " \n  " );
		fprintf (g, " LISTA SALARII \n  " );
		fprintf (g, " =============================================== ==================================================== =============== \n  " );
		fprintf (g, " COD || NUME || PRENUM || DEPARTAMENT || PROFESIE || VARSTA || LUNA 1 || LUNA 2 || LUNA 3 || DATE \n  " );
		fprintf (g, " =============================================== ==================================================== ==================== \n  " );
		printf ( " LISTA SALARI \n  " );
		printf ( " ================================================ ==================================================== ======================== \n  " );
		printf ( " COD || NUME || PRENUM || DEPARTAMENT || PROFESIE || VARSTA || LUNA 1 || LUNA 2 || LUNA 3 || DATE \n  " );
		printf ( " ================================================ ==================================================== ======================== \n  " );
		fread (&a, sizeof (ang), 1 , f);
		while (! feof (f)) // pana cand ajungi la sf fisierului
		{
			dacă (a. este == 1 )
			{
				printf ( " \n %5d|| %-20s || %-20s || %-15s || %-15s || %5d || %-7.2f || %-7.2f || %-7.2f | | %2d/%2d/%4d " , a. cod , a. nume , a. prenume , a. dep , a. prof , a. varsta , a. sal [ 0 ], a. sal [ 1 ], a . sal [ 2 ], a. data_ang . zi , a. data_ang . luna , a. data_ang . an );
				fprintf (g, " \n %5d|| %-20s || %-20s || %-15s || %-15s || %5d || %-7,2f || %-7,2f || %-7,2 f|| %2d/%2d/%4d " , a. cod , a. nume , a. prenume , a. dep , a. prof , a. varsta , a. sal [ 0 ], a. sal [ 1 ] , a. sal [ 2 ], a. data_ang . zi , a. data_ang . luna , a. data_ang . an );
			}
			fread (&a, sizeof (ang), 1 , f);
		}
		fclose (f); fclose (g);
	}
}

void  afisare_poz ()
{
	DOSAR* f, * g;
	ang a;
	int n;
	char nume_f[ 20 ];
	printf ( " \n nume fisier: " );
	gets_s (număr_f);
	if (!(f = fopen (nume_f, " rb " ))) printf ( " nu exista fisierul " );
	else {
		printf ( " \n afisarea inregistrarilor a caror pozitiei o citesc de la tastatura " );
		g = fopen ( " lista_poz.txt " , " w " );
		printf ( " \n  " );
		fprintf (g, " LISTA SALARII \n  " );
		fprintf (g, " =============================================== ================================================ \n  " );
		fprintf (g, " COD || NUME || PRENUM || VARSTA || LUNA 1 ||LUNA 2 || LUNA 3 \n  " );
		fprintf (g, " =============================================== ================================================= \ n  " );
		printf ( " \n n= " ); scanf ( " %d " , &n);
		în timp ce (! feof (stdin))
		{
			if (n > nr_art (f)) printf ( " depaseste lungimea fis. " );
			altfel
			{
				fseek (f, (n - 1 ) * sizeof (ang), 0 );
				fread (&a, sizeof (ang), 1 , f);
				dacă (a. este == 1 )
				{
					printf ( " \n %5d|| %-20s || %-20s ||%5d ||%5.2f||%5.2f||%5.2f " , n, a. nume , a. prenume , a. varsta , a. sal [ 0 ], a. sal [ 1 ], a. sal [ 2 ]);
					fprintf (g, " \n %5d|| %-20s || %-20s ||%5d ||%5.2f||%5.2f||%5.2f " , n, a. nume , a. prenume , a. varsta , a. sal [ 0 ], a. sal [ 1 ], a. sal [ 2 ]);
				}
				else  printf ( " inregistrarea nu exista " );
			}
			printf ( " \n n= " ); scanf ( " %d " , &n);
		}
		fclose (f); fclose (g);
	}
}

void  afisare_peBazaAnului ()
{
	DOSAR* f, * g;
	ang a;
	int an;
	char nume_f[ 20 ];
	printf ( " \n nume fisier: " );
	gets_s (număr_f);
	if (!(f = fopen (nume_f, " rb " ))) printf ( " nu exista fisierul " );
	else {
		printf ( " \n afisarea inregistrarilor pe baza anului " );
		g = fopen ( " lista_angPeBazaAnului.txt " , " w " );
		printf ( " \n  " );
		fprintf (g, " LISTA SALARII \n  " );
		fprintf (g, " =============================================== ================================================ \n  " );
		fprintf (g, " COD || NUME || PRENUM || VARSTA || LUNA 1 ||LUNA 2 || LUNA 3 \n  " );
		fprintf (g, " =============================================== ================================================= \ n  " );
		printf ( " \n an= " ); scanf ( " %d " , &an);
		în timp ce (! feof (stdin))
		{
			fread (&a, sizeof (ang), 1 , f);
			while (! feof (f)) // pana cand ajungi la sf fisierului
			{
				dacă (a. este == 1 && a. data_ang . an ==an)
				{
					printf ( " \n %5d|| %-20s || %-20s || %-15s || %-15s || %5d || %-7.2f || %-7.2f || %-7.2f | | %2d/%2d/%4d " , a. cod , a. nume , a. prenume , a. dep , a. prof , a. varsta , a. sal [ 0 ], a. sal [ 1 ], a . sal [ 2 ], a. data_ang . zi , a. data_ang . luna , a. data_ang . an );
					fprintf (g, " \n %5d|| %-20s || %-20s || %-15s || %-15s || %5d || %-7,2f || %-7,2f || %-7,2 f|| %2d/%2d/%4d " , a. cod , a. nume , a. prenume , a. dep , a. prof , a. varsta , a. sal [ 0 ], a. sal [ 1 ] , a. sal [ 2 ], a. data_ang . zi , a. data_ang . luna , a. data_ang . an );
				}
				fread (&a, sizeof (ang), 1 , f);
			}
			înapoi (f);
			printf ( " \n an= " ); scanf ( " %d " , &an);
		}
		fclose (f); fclose (g);
	}
}

void  main () {
	// #define SEEK_CUR 1
	// #define SEEK_END 2
	// #define SEEK_SET 0

	// printf("\n\POPULARE FISIER BINAR\n\n");
	// populare();
	// printf("\n\ADAUGARE IN FISIER BINAR\n\n");
	// adaugare();

	printf ( " \n\n AFISARE DIN FISIER BINAR \n\n " );
	afisare ();
	// printf("\n\AFISARE DIN FISIER BINAR PE BAZA CODULUI\n\n");
	// afisare_poz();
	printf ( " \n \AFISARE DIN FISIER BINAR PE BAZA ANULUI \n\n " );
	afisare_peBazaAnului ();
}
SEMINAR 5 EX 2
# include < stdio.h >
# include < șir.h >
# include < stdlib.h >

// fisier binar secvential
struct  DataStruct
{
	int zi;
	int luna;
	int an;
};

struct  Produs {
	int codDeBare;
	char denumire[ 50 ];
	float pret;
	int stoc;
	DataStruct dataExpirare;
};

// obtinere total elemente de tip Produs
int  getNrProduse (FILE* f) {
	int pozCurenta = ftell (f); // pastrarea pozitiei curente

	fseek (f, 0 , SEEK_END);
	int totalOcteti = ftell (f);

	fseek (f, pozCurenta, SEEK_SET);

	return totalOcteti / sizeof (Produs);
}

void  sortareFisierDupaDenumireSiPret ( char numeFisier[ 20 ]) {
	DOSAR* f;
	fopen_s (&f, numeFisier, " rb+ " );

	// fct strcmp(s1,s2) - compara 2 siruri de caractere si returneaza un nr ...face parte din libraria string.h
	// 0 -> daca sirurile sunt identice
	// <0 -> daca s1 < s2 --> adica daca sunt in ordine alfabetica s1 si s2
	// >0 -> daca s1 > s2 --> adica daca NU sunt in ordine alfabetica s1 si s2 ==> asta o sa folosim NOI mai jos.

	Produs a, b;
	int nrProduse = getNrProduse (f);

	dacă (f != NULL ) {
		pentru ( int i = 0 ; i < nrProduse - 1 ; i++) {
			fseek (f, i * sizeof (Produs), SEEK_SET);
			fread (&a, sizeof (Produs), 1 , f);

			pentru ( int j = i + 1 ; j < nrProduse; j++) {
				fseek (f, j * sizeof (Produs), SEEK_SET);
				fread (&b, sizeof (Produs), 1 , f);

				if ( strcmp (a. denumire , b. denumire ) > 0 || ( strcmp (a. denumire , b. denumire ) == 0 && a. pret > b. pret )) {
					fseek (f, i * sizeof (Produs), SEEK_SET);
					fwrite (&b, sizeof (Produs), 1 , f);

					fseek (f, j * sizeof (Produs), SEEK_SET);
					fwrite (&a, sizeof (Produs), 1 , f);
				}
			}
		}
		fclose (f);
	}
	else {
		printf ( " \n Fisierul %s nu exista! " , numeFisier);
	}
}

void  sortareFisierInMemorieInternaDupaDenumireSiPret ( char numeFisier[ 20 ]) {
	DOSAR* f;
	fopen_s (&f, numeFisier, " rb+ " );
	dacă (f != NULL ) {
		int nr = getNrProduse (f);

		Produs aux;
		Produs* pointerProduse = (Produs*) malloc ( sizeof (Produs) * nr);
		fread (pointerProduse, sizeof (Produs), nr, f); // scriem in vectorul dinamic de produse toate elementele din fisier.

		if (pointerProduse != NULL ) {
			pentru ( int i = 0 ; i < nr - 1 ; i++) {
				pentru ( int j = i + 1 ; j < nr; j++)
				{
					if ( strcmp (pointerProduse[i]. denumire , pointerProduse[j]. denumire ) > 0 ||
						( strcmp (pointerProduse[i]. denumire , pointerProduse[j]. denumire ) == 0 && pointerProduse[i]. pret > pointerProduse[j]. pret )) {
						aux = pointerProduse[i];
						pointerProduse[i] = pointerProduse[j];
						pointerProduse[j] = aux;
					}
				}
			}

			înapoi (f);
			fwrite (pointerProduse, sizeof (Produs), nr, f); // suprascrii tot fisierul cu vectorul tau
		}

		fclose (f);
		gratuit (pointerProduse);
	}
	else {
		printf ( " \n Fisierul %s nu exista! " , numeFisier);
	}
}

void  scriereInFisierBinarInModSecvential ( char numeFisier[ 20 ]) {
	DOSAR* f;
	fopen_s (&f, numeFisier, " ab " ); // deschide fisierul in mod de adaugare binara

	dacă (f != NULL ) {
		int continuare = 1 ;
		while (continuare == 1 )
		{
			Produs p;
			printf ( " \n Cod produs: " );
			scanf_s ( " %d " , &p. codDeBare );

			printf ( " Denumire produs: " );
			getc (stdin);
			gets_s (p. denumire , 50 );
			// scanf_s("%s", p.denumire, 50);

			printf ( " Pret produs: " );
			scanf_s ( " %f " , &p. pret );
			printf ( " Stoc produs: " );
			scanf_s ( " %d " , &p. stoc );

			printf ( " Data expirare produse -> zi: " );
			scanf_s ( " %d " , &p. dataExpirare . zi );
			printf ( " Data expirare produse -> luna: " );
			scanf_s ( " %d " , &p. dataExpirare . luna );
			printf ( " Data expirare produse -> an: " );
			scanf_s ( " %d " , &p. dataExpirare . an );

			fwrite (&p, sizeof (Produs), 1 , f);

			printf ( " \n Doriti sa continuati? (1/0) " );
			scanf_s ( " %d " , &continuare);
		}

		fclose (f);
	}
}

void  modificareProdus ( char numeFisier[ 20 ], int codBare) {
	DOSAR* f;
	fopen_s (&f, numeFisier, " rb+ " );
	int nrProduse = getNrProduse (f);

	dacă (f != NULL )
	{
		Produs p;
		int ok = 0 ;
		pentru ( int i = 0 ; i < nrProduse; i++) {
			fread (&p, dimensiunea (p), 1 , f);
			if (codBare == p. codDeBare ) {
				p. stoc += 20 ;
				p. pret -= 2 ;
				fseek (f, i * sizeof (p), SEEK_SET);
				fwrite (&p, sizeof (p), 1 , f);

				ok = 1 ;
				rupe ;
			}
		}

		dacă (ok == 1 ) {
			printf ( " Produsul cu codul de bare %da fost modificat. \n " , codBare);
		}
		else {
			printf ( " Produsul cu codul de bare %d nu exista. \n " , codBare);
		}
		fclose (f);
	}
	else {
		printf ( " \n Fisierul %s nu exista! " , numeFisier);
	}
}

// afisarea unui element de tip produs
void  afisareProdus (Produs p) {
	printf ( " \n Produsul %s cu codul %d are pretul %.2f si expira la data de %d.%d.%d. Avem un stoc de %d produse de acest tip. \n " ,
		p. denumire , p. codDeBare , p. pret , p. dataExpirare . zi , p. dataExpirare . luna , p. dataExpirare . o , p. stoc );
}

void  afisareProduseDinFisierBinar ( char numeFisier[ 20 ]) {
	DOSAR* f;
	fopen_s (&f, numeFisier, " rb " );

	Produs p;
	dacă (f != NULL ) {
		// sau puteati sa faceti ca in ex 1 cu !feof(f)
		while ( fread (&p, sizeof (Produs), 1 , f) == 1 ) {
			afisareProdus (p);
		}

		fclose (f);
	}
	else {
		printf ( " \n Fisierul %s nu exista! " , numeFisier);
	}
}

void  generareRaport ( char numeFisier[ 20 ]) {
	DOSAR* f;
	fopen_s (&f, numeFisier, " rb " );

	DOSAR* g;
	fopen_s (&g, " RaportProduse.txt " , " w " );

	Produs p;
	dacă (f != NULL ) {
		while ( fread (&p, sizeof (Produs), 1 , f) == 1 ) {
			fprintf (g, " \n Produsul %s cu codul %d are pretul %.2f si expira la data de %d.%d.%d. Avem un stoc de %d produse de acest tip. \n " ,
				p. denumire , p. codDeBare , p. pret , p. dataExpirare . zi , p. dataExpirare . luna , p. dataExpirare . o , p. stoc );
		}
		fclose (f);
	}
	else {
		printf ( " \n Fisierul %s nu exista! " , numeFisier);
	}
}

void  main () {
	char numeFisier[ 20 ];
	printf ( " Numele fisierului binar secvential: " );
	scanf_s ( " %s " , &numeFisier, 20 );

	printf ( " Vreti sa scrieti ceva in fisierul binar?(0/1) \n " );
	int ok = 0 ;
	scanf_s ( " %d " , &ok);
	dacă (ok == 1 ) {
		scriereInFisierBinarInModSecvential (numeFisier);
	}

	afisareProduseDinFisierBinar (numeFisier);

	printf ( " \n\n Afisare fisier dupa sortare. \n\n " );

	// sortareFisierDupaDenumireSiPret(numeFisier);
	sortareFisierInMemorieInternaDupaDenumireSiPret (numeFisier);

	afisareProduseDinFisierBinar (numeFisier);

	printf ( " \n === modificare produs === \n " );
	modificareProdus (numeFisier, 199 );

	printf ( " \n === generare raport === \n " );

	generareRaport (numeFisier);
}

